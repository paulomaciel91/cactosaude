-- Enable UUID extension
create extension if not exists "uuid-ossp";

-- Clinics table (Tenant)
create table if not exists public.clinics (
  id uuid default uuid_generate_v4() primary key,
  name text not null,
  cnpj text,
  address text,
  phone text,
  email text,
  owner_id uuid, -- Will be linked to auth.users later to avoid circular dependency issues during creation
  created_at timestamp with time zone default timezone('utc'::text, now()) not null,
  updated_at timestamp with time zone default timezone('utc'::text, now()) not null
);

-- RLS for clinics
alter table public.clinics enable row level security;

-- Profiles table (linked to auth.users)
create table if not exists public.profiles (
  id uuid references auth.users on delete cascade not null primary key,
  clinic_id uuid references public.clinics(id) on delete cascade,
  email text,
  full_name text,
  role text check (role in ('admin', 'medico', 'recepcionista', 'financeiro')),
  specialty text,
  phone text,
  crm text,
  created_at timestamp with time zone default timezone('utc'::text, now()) not null,
  updated_at timestamp with time zone default timezone('utc'::text, now()) not null
);

-- Update clinics owner_id foreign key
alter table public.clinics 
  add constraint fk_clinics_owner 
  foreign key (owner_id) 
  references public.profiles(id);

-- RLS for profiles
alter table public.profiles enable row level security;

-- Helper function to get current user's clinic_id
create or replace function public.get_my_clinic_id()
returns uuid as $$
  select clinic_id from public.profiles where id = auth.uid() limit 1;
$$ language sql security definer;

-- Policies for Clinics
create policy "Users can view their own clinic."
  on clinics for select
  using ( id = public.get_my_clinic_id() );

create policy "Users can update their own clinic."
  on clinics for update
  using ( id = public.get_my_clinic_id() );

-- Policies for Profiles
create policy "Users can view profiles from their clinic."
  on profiles for select
  using ( clinic_id = public.get_my_clinic_id() );

create policy "Users can update their own profile."
  on profiles for update
  using ( auth.uid() = id );

-- Patients table
create table if not exists public.patients (
  id bigint generated by default as identity primary key,
  clinic_id uuid references public.clinics(id) on delete cascade not null,
  name text not null,
  email text,
  phone text,
  cpf text,
  birth_date date,
  address text,
  photo text,
  health_insurance text,
  consultations_count int default 0,
  last_consultation date,
  balance numeric(10, 2) default 0,
  allergies text,
  chronic_diseases text,
  convenio_id int,
  convenio_nome text,
  carteirinha text,
  validade_carteirinha date,
  plano text,
  carencia text,
  titular text,
  created_at timestamp with time zone default timezone('utc'::text, now()) not null
);

-- RLS for patients
alter table public.patients enable row level security;

create policy "Users can view patients from their clinic"
  on patients for select
  using ( clinic_id = public.get_my_clinic_id() );

create policy "Users can insert patients to their clinic"
  on patients for insert
  with check ( clinic_id = public.get_my_clinic_id() );

create policy "Users can update patients from their clinic"
  on patients for update
  using ( clinic_id = public.get_my_clinic_id() );

create policy "Users can delete patients from their clinic"
  on patients for delete
  using ( clinic_id = public.get_my_clinic_id() );

-- Appointments table
create table if not exists public.appointments (
  id bigint generated by default as identity primary key,
  clinic_id uuid references public.clinics(id) on delete cascade not null,
  patient_id bigint references public.patients(id) on delete cascade,
  patient_name text, -- Denormalized
  professional_id uuid references public.profiles(id),
  professional_name text,
  phone text,
  date date not null,
  time time not null,
  type text,
  modality text check (modality in ('presencial', 'online')),
  status text check (status in ('confirmed', 'pending', 'cancelled')),
  duration int,
  created_at timestamp with time zone default timezone('utc'::text, now()) not null
);

-- RLS for appointments
alter table public.appointments enable row level security;

create policy "Users can view appointments from their clinic"
  on appointments for select
  using ( clinic_id = public.get_my_clinic_id() );

create policy "Users can insert appointments to their clinic"
  on appointments for insert
  with check ( clinic_id = public.get_my_clinic_id() );

create policy "Users can update appointments from their clinic"
  on appointments for update
  using ( clinic_id = public.get_my_clinic_id() );

create policy "Users can delete appointments from their clinic"
  on appointments for delete
  using ( clinic_id = public.get_my_clinic_id() );

-- Blocked Slots table
create table if not exists public.blocked_slots (
  id bigint generated by default as identity primary key,
  clinic_id uuid references public.clinics(id) on delete cascade not null,
  day int, -- 0-6
  date date,
  time time,
  duration int,
  reason text,
  professional_id uuid references public.profiles(id),
  professional_name text,
  created_at timestamp with time zone default timezone('utc'::text, now()) not null
);

-- RLS for blocked_slots
alter table public.blocked_slots enable row level security;

create policy "Users can view blocked slots from their clinic"
  on blocked_slots for select
  using ( clinic_id = public.get_my_clinic_id() );

create policy "Users can insert blocked slots to their clinic"
  on blocked_slots for insert
  with check ( clinic_id = public.get_my_clinic_id() );

create policy "Users can update blocked slots from their clinic"
  on blocked_slots for update
  using ( clinic_id = public.get_my_clinic_id() );

create policy "Users can delete blocked slots from their clinic"
  on blocked_slots for delete
  using ( clinic_id = public.get_my_clinic_id() );

-- Function to handle new user signup
create or replace function public.handle_new_user()
returns trigger as $
declare
  new_clinic_id uuid;
  user_full_name text;
  clinic_name text;
begin
  user_full_name := new.raw_user_meta_data->>'full_name';
  if user_full_name is null then
    user_full_name := 'Novo Usuario';
  end if;

  clinic_name := new.raw_user_meta_data->>'clinic_name';

  -- Check if clinic_id is provided in metadata (invitation flow)
  if new.raw_user_meta_data->>'clinic_id' is not null then
    new_clinic_id := (new.raw_user_meta_data->>'clinic_id')::uuid;
  else
    -- Create a new clinic for the user
    insert into public.clinics (name, email, cnpj)
    values (coalesce(clinic_name, 'Clinica de ' || user_full_name), new.email, new.raw_user_meta_data->>'clinic_cnpj')
    returning id into new_clinic_id;
  end if;

  -- Create profile linked to the clinic
  insert into public.profiles (id, clinic_id, email, full_name, role, phone)
  values (new.id, new_clinic_id, new.email, user_full_name, 'admin', new.raw_user_meta_data->>'phone'); -- Default to admin for new signups (owners)

  -- If it's a new clinic, set the owner
  if new.raw_user_meta_data->>'clinic_id' is null then
    update public.clinics set owner_id = new.id where id = new_clinic_id;
  end if;

  return new;
end;
$ language plpgsql security definer;

-- Trigger for new user
drop trigger if exists on_auth_user_created on auth.users;
create trigger on_auth_user_created
  after insert on auth.users
  for each row execute procedure public.handle_new_user();
